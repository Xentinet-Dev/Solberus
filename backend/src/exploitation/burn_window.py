"""
Burn Window Tracker - Tracks 24-hour timer for Mayhem Mode token burns.

Mayhem Mode tokens have a 24-hour window where the bot trades randomly,
then burns all remaining tokens. This module tracks the timer and triggers
pre-burn exits.
"""

import asyncio
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Any, Dict, Optional

from exploitation.mayhem_detector import MayhemTokenInfo
from utils.logger import get_logger

logger = get_logger(__name__)

# Mayhem Mode burn window duration (24 hours)
MAYHEM_BURN_WINDOW_SECONDS = 24 * 60 * 60  # 86400 seconds


@dataclass
class BurnWindowInfo:
    """Information about a token's burn window."""

    token_created_at: datetime
    burn_deadline: datetime
    time_remaining: timedelta
    time_remaining_seconds: float
    percentage_remaining: float  # 0.0 to 1.0
    should_exit_before_burn: bool = False
    exit_recommended_at: Optional[datetime] = None


class BurnWindowTracker:
    """
    Tracks the 24-hour burn window for Mayhem Mode tokens.

    The bot burns all remaining tokens after 24 hours, which can cause
    price spikes or crashes. This tracker monitors the window and recommends
    exits before the burn.
    """

    def __init__(self, exit_before_burn_minutes: int = 30):
        """Initialize the burn window tracker.

        Args:
            exit_before_burn_minutes: Minutes before burn to recommend exit
        """
        self.exit_before_burn_minutes = exit_before_burn_minutes
        self.tracked_tokens: Dict[str, BurnWindowInfo] = {}

    def track_token(
        self, mayhem_token: MayhemTokenInfo, token_created_at: datetime
    ) -> BurnWindowInfo:
        """Track a Mayhem Mode token's burn window.

        Args:
            mayhem_token: Mayhem token information
            token_created_at: When the token was created

        Returns:
            Burn window information
        """
        burn_deadline = token_created_at + timedelta(seconds=MAYHEM_BURN_WINDOW_SECONDS)
        now = datetime.utcnow()
        time_remaining = burn_deadline - now
        time_remaining_seconds = time_remaining.total_seconds()

        # Calculate percentage remaining
        if time_remaining_seconds > 0:
            percentage_remaining = time_remaining_seconds / MAYHEM_BURN_WINDOW_SECONDS
        else:
            percentage_remaining = 0.0

        # Determine if exit is recommended
        exit_recommended_at = burn_deadline - timedelta(
            minutes=self.exit_before_burn_minutes
        )
        should_exit_before_burn = now >= exit_recommended_at

        burn_info = BurnWindowInfo(
            token_created_at=token_created_at,
            burn_deadline=burn_deadline,
            time_remaining=time_remaining,
            time_remaining_seconds=time_remaining_seconds,
            percentage_remaining=percentage_remaining,
            should_exit_before_burn=should_exit_before_burn,
            exit_recommended_at=exit_recommended_at,
        )

        # Store tracking info
        token_key = str(mayhem_token.token_info.mint)
        self.tracked_tokens[token_key] = burn_info

        if should_exit_before_burn:
            logger.warning(
                f"Burn window exit recommended for {mayhem_token.token_info.symbol}: "
                f"{time_remaining_seconds/3600:.1f} hours remaining until burn"
            )

        return burn_info

    def get_burn_info(self, token_mint: str) -> Optional[BurnWindowInfo]:
        """Get burn window information for a token.

        Args:
            token_mint: Token mint address

        Returns:
            Burn window info if tracked, None otherwise
        """
        return self.tracked_tokens.get(token_mint)

    def update_tracking(self) -> Dict[str, BurnWindowInfo]:
        """Update all tracked tokens with current time.

        Returns:
            Updated burn window info for all tokens
        """
        now = datetime.utcnow()
        updated_tokens = {}

        for token_key, burn_info in self.tracked_tokens.items():
            # Recalculate time remaining
            time_remaining = burn_info.burn_deadline - now
            time_remaining_seconds = time_remaining.total_seconds()

            if time_remaining_seconds > 0:
                percentage_remaining = time_remaining_seconds / MAYHEM_BURN_WINDOW_SECONDS
            else:
                percentage_remaining = 0.0

            # Update exit recommendation
            should_exit_before_burn = now >= burn_info.exit_recommended_at

            updated_info = BurnWindowInfo(
                token_created_at=burn_info.token_created_at,
                burn_deadline=burn_info.burn_deadline,
                time_remaining=time_remaining,
                time_remaining_seconds=time_remaining_seconds,
                percentage_remaining=percentage_remaining,
                should_exit_before_burn=should_exit_before_burn,
                exit_recommended_at=burn_info.exit_recommended_at,
            )

            updated_tokens[token_key] = updated_info
            self.tracked_tokens[token_key] = updated_info

        return updated_tokens

    def get_tokens_near_burn(self, minutes_threshold: int = 60) -> Dict[str, BurnWindowInfo]:
        """Get tokens that are close to burn deadline.

        Args:
            minutes_threshold: Minutes before burn to consider "near"

        Returns:
            Dictionary of tokens near burn
        """
        now = datetime.utcnow()
        near_burn: Dict[str, BurnWindowInfo] = {}

        for token_key, burn_info in self.tracked_tokens.items():
            time_until_burn = (burn_info.burn_deadline - now).total_seconds() / 60

            if 0 <= time_until_burn <= minutes_threshold:
                near_burn[token_key] = burn_info

        return near_burn

    def get_summary(self) -> Dict[str, Any]:
        """Get summary of burn window tracking.

        Returns:
            Summary dictionary
        """
        now = datetime.utcnow()
        total_tracked = len(self.tracked_tokens)
        exit_recommended = sum(
            1 for info in self.tracked_tokens.values() if info.should_exit_before_burn
        )
        near_burn = len(self.get_tokens_near_burn())

        return {
            "total_tracked": total_tracked,
            "exit_recommended": exit_recommended,
            "near_burn": near_burn,
            "exit_before_burn_minutes": self.exit_before_burn_minutes,
        }


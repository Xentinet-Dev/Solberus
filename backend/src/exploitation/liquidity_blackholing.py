"""
Liquidity Blackholing Detector - Monitors Mayhem bot's liquidity draining behavior.

The Mayhem bot sells more than it buys, draining liquidity and trapping holders.
This module detects drain patterns and triggers early exits.
"""

import asyncio
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from solders.pubkey import Pubkey

from core.client import SolanaClient
from exploitation.mayhem_detector import MayhemTokenInfo
from utils.logger import get_logger

logger = get_logger(__name__)


@dataclass
class DrainAnalysis:
    """Analysis of liquidity drain for a Mayhem token."""

    drain_rate: float  # 0.0 to 1.0 (percentage of liquidity drained)
    drain_velocity: float  # Rate of drain per block
    exhaustion_risk: str  # "low", "medium", "high", "critical"
    estimated_time_to_exhaustion: Optional[int] = None  # blocks
    should_exit: bool = False
    exit_reason: Optional[str] = None


class LiquidityBlackholingDetector:
    """
    Detects and monitors liquidity blackholing in Mayhem Mode tokens.

    The Mayhem bot's selling behavior drains liquidity, creating exit traps.
    This detector monitors drain patterns and recommends early exits.
    """

    def __init__(self, client: SolanaClient):
        """Initialize the liquidity blackholing detector.

        Args:
            client: Solana RPC client
        """
        self.client = client
        self.monitored_tokens: Dict[str, Dict[str, Any]] = {}
        self.drain_threshold = 0.3  # Exit if 30% liquidity drained
        self.critical_threshold = 0.7  # Critical if 70% drained

    async def analyze_drain(
        self, mayhem_token: MayhemTokenInfo, bot_activity: Dict[str, Any]
    ) -> DrainAnalysis:
        """Analyze liquidity drain for a Mayhem token.

        Args:
            mayhem_token: Mayhem token information
            bot_activity: Bot activity statistics

        Returns:
            Drain analysis with recommendations
        """
        logger.debug(f"Analyzing liquidity drain for {mayhem_token.token_info.symbol}...")

        try:
            # Calculate drain rate based on bot activity
            drain_rate = await self._calculate_drain_rate(mayhem_token, bot_activity)

            # Calculate drain velocity (rate per block)
            drain_velocity = await self._calculate_drain_velocity(
                mayhem_token, bot_activity
            )

            # Estimate time to exhaustion
            time_to_exhaustion = None
            if drain_velocity > 0:
                remaining_liquidity = 1.0 - drain_rate
                if remaining_liquidity > 0:
                    time_to_exhaustion = int(remaining_liquidity / drain_velocity)

            # Determine exhaustion risk
            if drain_rate >= self.critical_threshold:
                exhaustion_risk = "critical"
            elif drain_rate >= 0.5:
                exhaustion_risk = "high"
            elif drain_rate >= 0.3:
                exhaustion_risk = "medium"
            else:
                exhaustion_risk = "low"

            # Determine if exit is recommended
            should_exit = drain_rate >= self.drain_threshold
            exit_reason = None

            if should_exit:
                if drain_rate >= self.critical_threshold:
                    exit_reason = f"CRITICAL: {drain_rate*100:.1f}% liquidity drained"
                else:
                    exit_reason = f"WARNING: {drain_rate*100:.1f}% liquidity drained"

            analysis = DrainAnalysis(
                drain_rate=drain_rate,
                drain_velocity=drain_velocity,
                exhaustion_risk=exhaustion_risk,
                estimated_time_to_exhaustion=time_to_exhaustion,
                should_exit=should_exit,
                exit_reason=exit_reason,
            )

            # Store analysis
            token_key = str(mayhem_token.token_info.mint)
            self.monitored_tokens[token_key] = {
                "analysis": analysis,
                "timestamp": asyncio.get_event_loop().time(),
            }

            if should_exit:
                logger.warning(
                    f"Liquidity drain detected for {mayhem_token.token_info.symbol}: "
                    f"{exit_reason}"
                )

            return analysis

        except Exception as e:
            logger.exception(f"Error analyzing drain: {e}")
            return DrainAnalysis(
                drain_rate=0.0,
                drain_velocity=0.0,
                exhaustion_risk="low",
                should_exit=False,
            )

    async def _calculate_drain_rate(
        self, mayhem_token: MayhemTokenInfo, bot_activity: Dict[str, Any]
    ) -> float:
        """Calculate the current liquidity drain rate.

        Args:
            mayhem_token: Mayhem token information
            bot_activity: Bot activity statistics

        Returns:
            Drain rate (0.0 to 1.0)
        """
        try:
            # If bot is selling more than buying, liquidity is draining
            net_activity = bot_activity.get("net_activity", 0)
            total_activity = bot_activity.get("buys", 0) + bot_activity.get("sells", 0)

            if total_activity == 0:
                return 0.0

            # Negative net_activity means more selling (draining)
            if net_activity < 0:
                # Calculate drain rate based on sell/buy ratio
                sells = bot_activity.get("sells", 0)
                buys = bot_activity.get("buys", 0)

                if buys == 0:
                    # All selling, maximum drain
                    return min(1.0, sells / 100.0)  # Cap at 100%

                # Drain rate proportional to sell/buy ratio
                sell_ratio = sells / (buys + sells)
                drain_rate = sell_ratio * 0.5  # Scale down (not all sells drain liquidity)

                return min(drain_rate, 1.0)

            return 0.0

        except Exception as e:
            logger.exception(f"Error calculating drain rate: {e}")
            return 0.0

    async def _calculate_drain_velocity(
        self, mayhem_token: MayhemTokenInfo, bot_activity: Dict[str, Any]
    ) -> float:
        """Calculate the rate of drain per block.

        Args:
            mayhem_token: Mayhem token information
            bot_activity: Bot activity statistics

        Returns:
            Drain velocity (drain per block)
        """
        try:
            # Calculate how fast liquidity is draining
            # Based on recent activity patterns

            net_activity = bot_activity.get("net_activity", 0)
            if net_activity >= 0:
                return 0.0  # Not draining

            # Negative net_activity indicates draining
            # Estimate velocity based on activity volume
            total_activity = bot_activity.get("buys", 0) + bot_activity.get("sells", 0)

            if total_activity == 0:
                return 0.0

            # Rough estimate: each negative net_activity point = some drain
            # This is simplified - real implementation would track over time
            velocity = abs(net_activity) / max(total_activity, 1) * 0.01

            return min(velocity, 0.1)  # Cap at 10% per block

        except Exception as e:
            logger.exception(f"Error calculating drain velocity: {e}")
            return 0.0

    async def monitor_token(
        self, mayhem_token: MayhemTokenInfo, bot_activity: Dict[str, Any]
    ) -> DrainAnalysis:
        """Monitor a token for liquidity blackholing.

        Args:
            mayhem_token: Mayhem token information
            bot_activity: Current bot activity

        Returns:
            Drain analysis
        """
        return await self.analyze_drain(mayhem_token, bot_activity)

    def get_monitored_tokens(self) -> Dict[str, Any]:
        """Get all monitored tokens and their drain status.

        Returns:
            Dictionary of monitored tokens
        """
        return self.monitored_tokens.copy()

    def get_summary(self) -> Dict[str, Any]:
        """Get summary of liquidity blackholing detection.

        Returns:
            Summary dictionary
        """
        critical = sum(
            1
            for data in self.monitored_tokens.values()
            if data["analysis"].exhaustion_risk == "critical"
        )
        high = sum(
            1
            for data in self.monitored_tokens.values()
            if data["analysis"].exhaustion_risk == "high"
        )
        medium = sum(
            1
            for data in self.monitored_tokens.values()
            if data["analysis"].exhaustion_risk == "medium"
        )
        low = sum(
            1
            for data in self.monitored_tokens.values()
            if data["analysis"].exhaustion_risk == "low"
        )

        exit_recommended = sum(
            1
            for data in self.monitored_tokens.values()
            if data["analysis"].should_exit
        )

        return {
            "total_monitored": len(self.monitored_tokens),
            "critical": critical,
            "high": high,
            "medium": medium,
            "low": low,
            "exit_recommended": exit_recommended,
        }

